"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1202],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>m,MDXProvider:()=>p,mdx:()=>x,useMDXComponents:()=>c,withMDXComponents:()=>d});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(){return a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},a.apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var m=r.createContext({}),d=function(e){return function(n){var t=c(n.components);return r.createElement(e,a({},n,{components:t}))}},c=function(e){var n=r.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(m.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=c(t),p=i,h=d["".concat(o,".").concat(p)]||d[p]||u[p]||a;return t?r.createElement(h,l(l({ref:n},m),{},{components:t})):r.createElement(h,l({ref:n},m))}));function x(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,o=new Array(a);o[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var m=2;m<a;m++)o[m]=t[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},17920:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>m,toc:()=>c});var r=t(83117),i=t(80102),a=(t(67294),t(3905)),o=["components"],l={id:"linters",title:"Linters",sidebar_label:"Linters"},s=void 0,m={unversionedId:"internals/linters",id:"internals/linters",title:"Linters",description:"Flipper Desktop comes with a variety of ESLint checks pre-enabled, which enable us to enforce sustainable coding practices and skip over discussions in code reviews.",source:"@site/../docs/internals/linters.mdx",sourceDirName:"internals",slug:"/internals/linters",permalink:"/docs/internals/linters",draft:!1,editUrl:"https://github.com/facebook/flipper/blob/main/website/../docs/internals/linters.mdx",tags:[],version:"current",frontMatter:{id:"linters",title:"Linters",sidebar_label:"Linters"},sidebar:"main",previous:{title:"Device Identifiers",permalink:"/docs/internals/device-identifiers"},next:{title:"Public Flipper Releases",permalink:"/docs/extending/public-releases"}},d={},c=[{value:"Specific Linters",id:"specific-linters",level:2},{value:"<code>promise/no-nesting</code>",id:"promiseno-nesting",level:3},{value:"Example",id:"example",level:4},{value:"<code>flipper/no-console-error-without-context</code>",id:"flipperno-console-error-without-context",level:3},{value:"Example",id:"example-1",level:4},{value:"<code>promise/catch-or-return</code>",id:"promisecatch-or-return",level:3},{value:"Example",id:"example-2",level:4},{value:"<code>communist-spelling/communist-spelling</code>",id:"communist-spellingcommunist-spelling",level:3},{value:"Example",id:"example-3",level:4},{value:"<code>node/no-sync</code>",id:"nodeno-sync",level:3}],p={toc:c};function u(e){var n=e.components,t=(0,i.Z)(e,o);return(0,a.mdx)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"Flipper Desktop comes with a variety of ESLint checks pre-enabled, which enable us to enforce sustainable coding practices and skip over discussions in code reviews."),(0,a.mdx)("h2",{id:"specific-linters"},"Specific Linters"),(0,a.mdx)("p",null,"This section contains an incomplete list of unusual linters we deploy, why we use them, and how to fix them (where relevant)."),(0,a.mdx)("h3",{id:"promiseno-nesting"},(0,a.mdx)("inlineCode",{parentName:"h3"},"promise/no-nesting")),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Summary"),"  - avoid nested then() or catch() statements. For more details, see ",(0,a.mdx)("a",{parentName:"li",href:"https://github.com/xjamundx/eslint-plugin-promise/blob/development/docs/rules/no-nesting.md"},"no-nesting.md")," on GitHub."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Why")," - nested promise chains can be difficult to read and understand. Often, you can achieve the same result by either returning the promise and handling them on a higher level or converting them to an async function.")),(0,a.mdx)("h4",{id:"example"},"Example"),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Before")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"private pushFileToiOSDevice(\n  udid: string,\n  bundleId: string,\n  destination: string,\n  filename: string,\n  contents: string,\n): Promise<void> {\n  return tmpDir({unsafeCleanup: true}).then((dir) => {\n    const filePath = path.resolve(dir, filename);\n    promisify(fs.writeFile)(filePath, contents).then(() =>\n      iosUtil.push(\n        udid,\n        filePath,\n        bundleId,\n        destination,\n        this.config.idbPath,\n      ),\n    );\n  });\n}\n")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"After")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"async pushFileToiOSDevice(\n  udid: string,\n  bundleId: string,\n  destination: string,\n  filename: string,\n  contents: string,\n): Promise<void> {\n  const dir = await tmpDir({unsafeCleanup: true});\n  const filePath = path.resolve(dir, filename);\n  await fs.writeFile(filePath, contents);\n  return iosUtil.push(\n    udid,\n    filePath,\n    bundleId,\n    destination,\n    this.config.idbPath,\n  );\n}\n")),(0,a.mdx)("p",null,"In addition to less indentation, you also maintain the promise chain here, meaning that you can handle potential errors on the call-side."),(0,a.mdx)("h3",{id:"flipperno-console-error-without-context"},(0,a.mdx)("inlineCode",{parentName:"h3"},"flipper/no-console-error-without-context")),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Summary")," - avoid 'naked' console.error calls. Prefer ",(0,a.mdx)("inlineCode",{parentName:"li"},'console.error("Failed to connect open iOS connection socket", e)')," to ",(0,a.mdx)("inlineCode",{parentName:"li"},"console.error(e)"),"."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Why")," - we create error tasks internally for every ",(0,a.mdx)("inlineCode",{parentName:"li"},"console.error")," call. It can be hard to find the origin of the error without context.")),(0,a.mdx)("h4",{id:"example-1"},"Example"),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Before")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"try {\n    // ...\n} catch (e) {\n    console.error(e);\n}\n")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"After")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"try {\n    // ...\n} catch (e) {\n    console.error(`Failed to connect to paste host ${hostname}`, e);\n}\n")),(0,a.mdx)("h3",{id:"promisecatch-or-return"},(0,a.mdx)("inlineCode",{parentName:"h3"},"promise/catch-or-return")),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Summary")," - ensure that each time a ",(0,a.mdx)("inlineCode",{parentName:"li"},"then()")," is applied to a promise, a ",(0,a.mdx)("inlineCode",{parentName:"li"},"catch()")," is applied as well. Exceptions are made if you are returning that promise. For more details, see ",(0,a.mdx)("a",{parentName:"li",href:"https://github.com/xjamundx/eslint-plugin-promise/blob/development/docs/rules/catch-or-return.md"},"catch-or-return.md")," on GitHub."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Why:"),' Unhandled exceptions have no stack trace and will just show up as "Unhandled promise rejection", making them very hard to triage and reproduce. By always ensuring that promises are returned (ensuring they are a chain) or explicitly catching errors, we can improve the user experience by acting more quickly on errors.')),(0,a.mdx)("h4",{id:"example-2"},"Example"),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Before")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},'function request() {\n    // If fetch() fails, the exception will bubble to the top.\n    fetch("https://example.com").then(res => {\n        doSomethingWith(res);\n    });\n}\n')),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"After")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},'// Option 1\nfunction request() {\n    fetch("https://example.com").then(res => {\n        doSomethingWith(res);\n    }).catch((e) => {\n        console.error("Failed to fetch from example.com", e);\n    });\n}\n\n// Option 2\nfunction request() {\n    // Allow the call-site to handle the error.\n    return fetch("https://example.com").then(res => {\n        doSomethingWith(res);\n    });\n}\n')),(0,a.mdx)("h3",{id:"communist-spellingcommunist-spelling"},(0,a.mdx)("inlineCode",{parentName:"h3"},"communist-spelling/communist-spelling")),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Summary")," - we try to avoid using British spellings for identifiers."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Why")," - this is clearly controversial, but it's very inconvenient when you have to bridge American and British APIs. ",(0,a.mdx)("inlineCode",{parentName:"li"},"const greyColour = COLORS.GRAY;")," is something nobody should have to read or write.")),(0,a.mdx)("h4",{id:"example-3"},"Example"),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Before")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"const GreyedOutOverlay = initialiseComponent();\n")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"After")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"const GrayedOutOverlay = initializeComponent();\n")),(0,a.mdx)("h3",{id:"nodeno-sync"},(0,a.mdx)("inlineCode",{parentName:"h3"},"node/no-sync")),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Summary"),": Use asynchronous methods wherever possible. ",(0,a.mdx)("a",{parentName:"li",href:"https://github.com/mysticatea/eslint-plugin-node/blob/master/docs/rules/no-sync.md"},"More details.")),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Why"),": Synchronous method calls block the event loop. Even innocuous calls like ",(0,a.mdx)("inlineCode",{parentName:"li"},"fs.existsSync()")," can cause frame drops for users or even long stalls."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"How to fix it"),": We have ",(0,a.mdx)("inlineCode",{parentName:"li"},"fs-extra")," as a dependency, which provides Promise-based alternatives for all ",(0,a.mdx)("inlineCode",{parentName:"li"},"fs")," functions. Most often, replacing a sync call with an async call and adding an ",(0,a.mdx)("inlineCode",{parentName:"li"},"await")," is all that's needed.")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Before")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"import fs from 'fs';\nfunction ensureCertsExist() {\n    if (\n        !(\n        fs.existsSync(serverKey) &&\n        fs.existsSync(serverCert) &&\n        fs.existsSync(caCert)\n        )\n    ) {\n        return generateServerCertificate();\n    }\n}\n")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"After")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"import fsExtra from 'fs-extra';\nasync function ensureCertsExist() {\n    const allExist = Promise.all([\n        fsExtra.exists(serverKey),\n        fsExtra.exists(serverCert),\n        fsExtra.exists(caCert),\n        ]).then((exist) => exist.every(Boolean));\n    if (!allExist) {\n      return this.generateServerCertificate();\n    }\n}\n")))}u.isMDXComponent=!0}}]);
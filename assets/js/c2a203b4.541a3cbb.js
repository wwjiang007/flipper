"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1323],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>d,MDXProvider:()=>m,mdx:()=>g,useMDXComponents:()=>c,withMDXComponents:()=>p});var i=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},o.apply(this,arguments)}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var d=i.createContext({}),p=function(e){return function(n){var t=c(n.components);return i.createElement(e,o({},n,{components:t}))}},c=function(e){var n=i.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=c(e.components);return i.createElement(d.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(t),m=a,h=p["".concat(r,".").concat(m)]||p[m]||u[m]||o;return t?i.createElement(h,l(l({ref:n},d),{},{components:t})):i.createElement(h,l({ref:n},d))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var d=2;d<o;d++)r[d]=t[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"},4029:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>c});var i=t(83117),a=t(80102),o=(t(67294),t(3905)),r=["components"],l={id:"new-clients",title:"Implementing a Flipper Client"},s=void 0,d={unversionedId:"extending/new-clients",id:"extending/new-clients",title:"Implementing a Flipper Client",description:"In the GitHub repo, you'll find Flipper clients for Android, iOS and C++ code, but there's nothing to stop you from writing a FlipperClient for another device or OS.",source:"@site/../docs/extending/new-clients.mdx",sourceDirName:"extending",slug:"/extending/new-clients",permalink:"/docs/extending/new-clients",draft:!1,editUrl:"https://github.com/facebook/flipper/blob/main/website/../docs/extending/new-clients.mdx",tags:[],version:"current",frontMatter:{id:"new-clients",title:"Implementing a Flipper Client"},sidebar:"main",previous:{title:"React Native Issues",permalink:"/docs/getting-started/troubleshooting/react-native"},next:{title:"Secure Communication",permalink:"/docs/extending/establishing-a-connection"}},p={},c=[{value:"Establishing a connection",id:"establishing-a-connection",level:2},{value:"Responding to messages",id:"responding-to-messages",level:2},{value:"Methods",id:"methods",level:3},{value:"getPlugins",id:"getplugins",level:4},{value:"getBackgroundPlugins",id:"getbackgroundplugins",level:4},{value:"init",id:"init",level:4},{value:"deinit",id:"deinit",level:4},{value:"execute",id:"execute",level:4},{value:"Error Reporting",id:"error-reporting",level:2},{value:"Testing",id:"testing",level:2}],m={toc:c};function u(e){var n=e.components,t=(0,a.Z)(e,r);return(0,o.mdx)("wrapper",(0,i.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"In the GitHub repo, you'll find Flipper clients for Android, iOS and C++ code, but there's nothing to stop you from writing a FlipperClient for another device or OS."),(0,o.mdx)("p",null,"Flipper clients communicate with the Flipper desktop app using JSON RPC messages over a ",(0,o.mdx)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc6455"},"WebSocket")," connection."),(0,o.mdx)("p",null,"This page documents the API. For reference, use the ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/facebook/flipper/blob/main/xplat/Flipper/FlipperConnectionManagerImpl.cpp"},"FlipperConnectionManagerImpl.cpp"),"."),(0,o.mdx)("h2",{id:"establishing-a-connection"},"Establishing a connection"),(0,o.mdx)("p",null,"Start by connecting to the Flipper server running within the desktop app. Connecting to the server registers your application with Flipper and enables plugins to interact with it. As the Flipper desktop has a different lifecycle than your app and may connect and disconnect at any time, it's important that you continue to attempt to reconnect to the Flipper server until it accepts your connection."),(0,o.mdx)("p",null,"The WebSocket protocol is used for communication between desktop and client because it enables easy certificate pinning and functionality, such as with request-response messages."),(0,o.mdx)("p",null,"In order to securely connect to Flipper, your client should first ",(0,o.mdx)("a",{parentName:"p",href:"/docs/extending/establishing-a-connection"},"obtain a certificate"),"."),(0,o.mdx)("p",null,"After the client certificate has been obtained, connect to the following URL with a WebSocket client:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-bash"},"localhost:9088/sonar?os={OS}\n                     &device={DEVICE}\n                     &device_id={DEVICE_ID}\n                     &app={APP}\n                     &sdk_version={SDK_VERSION}\n                     &foreground={FOREGROUND}\n")),(0,o.mdx)("p",null,"The URL parameters are detailed in the following table."),(0,o.mdx)("table",null,(0,o.mdx)("thead",{parentName:"table"},(0,o.mdx)("tr",{parentName:"thead"},(0,o.mdx)("th",{parentName:"tr",align:"left"},"Parameter"),(0,o.mdx)("th",{parentName:"tr",align:"left"},"Detail"),(0,o.mdx)("th",{parentName:"tr",align:"left"},"Example"))),(0,o.mdx)("tbody",{parentName:"table"},(0,o.mdx)("tr",{parentName:"tbody"},(0,o.mdx)("td",{parentName:"tr",align:"left"},(0,o.mdx)("inlineCode",{parentName:"td"},"OS")),(0,o.mdx)("td",{parentName:"tr",align:"left"},"The OS from which the connection is being established. This is usually hard coded into the FlipperClient implementation. This string may be used by the Flipper desktop app to identify valid plugins as well as present in the UI to the user."),(0,o.mdx)("td",{parentName:"tr",align:"left"},(0,o.mdx)("inlineCode",{parentName:"td"},"os=Android")," (",(0,o.mdx)("em",{parentName:"td"},"If your client is running on Android"),").")),(0,o.mdx)("tr",{parentName:"tbody"},(0,o.mdx)("td",{parentName:"tr",align:"left"},(0,o.mdx)("inlineCode",{parentName:"td"},"DEVICE")),(0,o.mdx)("td",{parentName:"tr",align:"left"},"The name of the device running the application."),(0,o.mdx)("td",{parentName:"tr",align:"left"},(0,o.mdx)("inlineCode",{parentName:"td"},"device=iPhone7"))),(0,o.mdx)("tr",{parentName:"tbody"},(0,o.mdx)("td",{parentName:"tr",align:"left"},(0,o.mdx)("inlineCode",{parentName:"td"},"DEVICE_ID")),(0,o.mdx)("td",{parentName:"tr",align:"left"},"A unique identifier for the device. The Flipper server / desktop app may use this to coalesce multiple connections originating from the save device or present the string in the UI to differentiate between connections to different clients."),(0,o.mdx)("td",{parentName:"tr",align:"left"})),(0,o.mdx)("tr",{parentName:"tbody"},(0,o.mdx)("td",{parentName:"tr",align:"left"},(0,o.mdx)("inlineCode",{parentName:"td"},"APP")),(0,o.mdx)("td",{parentName:"tr",align:"left"},"The name of the app running this client instance. The combination of ",(0,o.mdx)("inlineCode",{parentName:"td"},"OS")," + ",(0,o.mdx)("inlineCode",{parentName:"td"},"DEVICE_ID")," + ",(0,o.mdx)("inlineCode",{parentName:"td"},"APP")," uniquely identifies a connection."),(0,o.mdx)("td",{parentName:"tr",align:"left"},(0,o.mdx)("inlineCode",{parentName:"td"},"app=Facebook")," (",(0,o.mdx)("em",{parentName:"td"},"When connecting to a running facebook app"),").")),(0,o.mdx)("tr",{parentName:"tbody"},(0,o.mdx)("td",{parentName:"tr",align:"left"},(0,o.mdx)("inlineCode",{parentName:"td"},"FOREGROUND")," (Optional)"),(0,o.mdx)("td",{parentName:"tr",align:"left"},"A Boolean indicating whether this connection was established with a foreground process. This is a hint to the Flipper desktop app of whether to re-focus on this connection or not. Though optional, this paramater is recommended."),(0,o.mdx)("td",{parentName:"tr",align:"left"},(0,o.mdx)("inlineCode",{parentName:"td"},"foreground=true"))),(0,o.mdx)("tr",{parentName:"tbody"},(0,o.mdx)("td",{parentName:"tr",align:"left"},(0,o.mdx)("inlineCode",{parentName:"td"},"SDK_VERSION")),(0,o.mdx)("td",{parentName:"tr",align:"left"},"A number indicating the latest protocol version with which the client is compatible. You can find the current version in the ",(0,o.mdx)("a",{parentName:"td",href:"https://github.com/facebook/flipper/blob/main/xplat/Flipper/FlipperConnectionManagerImpl.cpp#L37"},"C++ connection implementation"),". Usually stored as a constant in the client code, this allows protocol changes to be made whilst still preserving connectivity with old clients. When Flipper desktop encounters an old SDK version, it may attempt to communicate using a matching protocol. However, backwards compatibility is not guaranteed, and you should strive to update clients on the rare occasion that the protocol version advances."),(0,o.mdx)("td",{parentName:"tr",align:"left"})))),(0,o.mdx)("h2",{id:"responding-to-messages"},"Responding to messages"),(0,o.mdx)("p",null,"Flipper uses a simple Remote Procedure Call (RPC) protocol using JSON-formatted payloads:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"method")," field of the payload indicates which method of the FlipperClient is being called. This will always be present."),(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"payload")," field contains the JSON parameters for the method call. This may be omitted when no parameters are used.")),(0,o.mdx)("p",null,"It is recommended that implementations gracefully ignore extra fields for the sake of backwards and forwards compatibility."),(0,o.mdx)("p",null,"Responses contain either a success object representing the return value of the RPC invocation or an error object indicating that an error occurred."),(0,o.mdx)("h3",{id:"methods"},"Methods"),(0,o.mdx)("p",null,"The methods detailed in the following sub-sections must be implemented by all FlipperClient implementations."),(0,o.mdx)("p",null,"The syntax used for these type definitions is ",(0,o.mdx)("a",{parentName:"p",href:"https://flow.org/en/docs/types/objects/"},"Flow"),". All requests/responses are JSON objects. Where no Response type is specified, it's a void call - no response is expected."),(0,o.mdx)("h4",{id:"getplugins"},"getPlugins"),(0,o.mdx)("p",null,"Return the available plugins as a list of identifiers. A plugin identifier is a string which is matched with the plugin identifier of desktop javascript plugins. This allows the client to specify the plugins it supports."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},'Request = {\n  "method": "getPlugins",\n}\n\nResponse = {\n  "success": {\n    "plugins": Array<string>\n  },\n}\n')),(0,o.mdx)("h4",{id:"getbackgroundplugins"},"getBackgroundPlugins"),(0,o.mdx)("p",null,"Returns a subset of the available plugins returned by ",(0,o.mdx)("inlineCode",{parentName:"p"},"getPlugin"),". The background connections will automatically receive a connection from Flipper once it starts (and if the plugins are enabled), rather than waiting for the user to open the plugin."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},'Request = {\n  "method": "getBackgroundPlugins",\n}\n\nResponse = {\n  "success": {\n    "plugins": Array<string>\n  },\n}\n')),(0,o.mdx)("h4",{id:"init"},"init"),(0,o.mdx)("p",null,"Initialize a plugin. This should result in an onConnected call on the appropriate plugin. Plugins should by nature be lazy and should not be initialized up front as this may incur significant cost. The Flipper desktop client knows when a plugin is needed and should control when to initialize them."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},'Request = {\n  "method": "init",\n  "params": {\n    "plugin": string,\n  },\n}\n')),(0,o.mdx)("h4",{id:"deinit"},"deinit"),(0,o.mdx)("p",null,"This is the opposite of ",(0,o.mdx)("a",{parentName:"p",href:"#init"},"init"),". A call to deinit is made when a plugin is no longer needed and should release any resources. Don't rely only on deinit to release plugin resources as Flipper may quit without having the chance to issue a deinit call. In such ases, you should also rely on the WebSocket disconnect callbacks. This call is mainly for allowing the desktop app to control the lifecycle of plugins."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},'Request = {\n  "method": "deinit",\n  "params": {\n    "plugin": string,\n  },\n}\n')),(0,o.mdx)("h4",{id:"execute"},"execute"),(0,o.mdx)("p",null,"This is the main call and how the Flipper desktop plugins and client plugins communicate. When a javascript desktop plugin issues a client request, it will be wrapped in one of these execute calls. This execute indicates that the call should be redirected to a plugin:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"request.params.api")," - the plugin id."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"request.params.method")," - the method within the plugin to execute."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"request.params.params")," - an optional params object containing the parameters to the RPC invocation.")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},'Request = {\n  "method": "execute",\n  "params": {\n    "api": string,\n    "method": string,\n    "params": ?Object,\n  },\n}\n\nResponse = {\n  "success": Object,\n} | {\n  "error": Object,\n}\n')),(0,o.mdx)("h2",{id:"error-reporting"},"Error Reporting"),(0,o.mdx)("p",null,"The Flipper desktop app handles error reporting. If an error occurs during the execution of an RPC invocation, it returns a serialization of it in the response so it can be attributed to the method call."),(0,o.mdx)("p",null,"If an error occurs in some other context, you can proactively send it to Flipper with the following request structure:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},"Request = {\n  error: {\n    message: string,\n    stacktrace: string,\n  }\n}\n")),(0,o.mdx)("p",null,"While in development mode, Flipper will display any client errors next to javascript errors in the Chrome Developer Tools console."),(0,o.mdx)("h2",{id:"testing"},"Testing"),(0,o.mdx)("p",null,"Testing is incredibly important when building core infrastructure and tools. The following is pseudocode for tests any new FlipperClient implementation is expected to implement and correctly execute. To run tests, it's strongly recommended that you to build a mock for the WebSocket connection to mock out the desktop side of the protocol and to not have any network dependencies in your test code."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},'test("GetPlugins", {\n  let connection = new MockConnection();\n  let client = new FlipperClient(connection);\n  let plugin = {id: "test"};\n\n  client.addPlugin(plugin);\n  client.start();\n\n  connection.onReceive({\n    id: 1,\n    method: "getPlugins",\n  });\n\n  assert(connection.sentMessages, contains({\n    id: 1,\n    success:{\n      plugins: ["test"],\n    },\n  }));\n});\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},'test("InitDeinit", {\n  let connection = new MockConnection();\n  let client = new FlipperClient(connection);\n  let plugin = {id: "test", connected: false};\n\n  client.addPlugin(plugin);\n  client.start();\n\n  assertFalse(plugin.connected);\n\n  connection.onReceive({\n    id: 1,\n    method: "init",\n    params: {\n      plugin: "test",\n    },\n  });\n\n  assertTrue(plugin.connected);\n\n  connection.onReceive({\n    id: 1,\n    method: "deinit",\n    params: {\n      plugin: "test",\n    },\n  });\n\n  assertFalse(plugin.connected);\n});\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},'test("Disconnect", {\n  let connection = new MockConnection();\n  let client = new FlipperClient(connection);\n  let plugin = {id: "test", connected: false};\n\n  client.addPlugin(plugin);\n  client.start();\n\n  assertFalse(plugin.connected);\n\n  connection.onReceive({\n    id: 1,\n    method: "init",\n    params: {\n      plugin: "test",\n    },\n  });\n\n  assertTrue(plugin.connected);\n  connection.disconnect();\n  assertFalse(plugin.connected);\n});\n')),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},'test("Execute", {\n  let connection = new MockConnection();\n  let client = new FlipperClient(connection);\n  let plugin = {\n    id: "test",\n    reverse: (params, responder) => {\n      responder.success({word: params.word.reverse()});\n    },\n  };\n\n  client.addPlugin(plugin);\n  client.start();\n\n  connection.onReceive({\n    id: 1,\n    method: "init",\n    params: {\n      plugin: "test",\n    },\n  });\n\n  connection.onReceive({\n    id: 1,\n    method: "execute",\n    params: {\n      api: "test",\n      method: "reverse",\n      params: {\n        word: "hello"\n      },\n    },\n  });\n\n  assert(connection.sentMessages, contains({\n    id: 1,\n    success:{\n      word: "olleh",\n    },\n  }));\n});\n')))}u.isMDXComponent=!0}}]);